# linear-validation
Validation module of the **Linear Framework**.

## API
The Validation API consists of two parts: **Constraints** and **Validations**.  
Constraints are defined on classes.  Validations are run on instances of those classes.  
Constraints and Validations are made available by mixing in the `Validation` trait on your class. 

### Quick Demo
```scala
import com.linearframework.validation._

case class Person(name: String, age: Int) extends Validation {
  override protected def constraints(): Unit = {
    "Name is required" validates that(name) prohibits { _.name.isEmpty }
    "Age must be 18+" validates that(age) requires { _.age >= 18 }
  }
}

Person("Billy", 20).validate   // returns Person("Billy", 20)
Person("Sally", 14).validate   // returns a ValidationException
```

### Constraints
A **Constraint** is applied to a class and consists of three parts:
 - a **field** ("name")
 - a **message** ("Name is required")
 - a **test** (`_.name.nonEmpty`)

Validation messages are specific to the **field** being constrained.  Every constraint must be applied to a single
field in the class.  Multiple constraints may be applied to the same field.

The **message** is the error returned when validation fails.  If validation succeeds, the message is not used.

The **test** is a function that executes over an instance of the class, returning `true` or `false`.  Tests may take one of two forms:
 - `requires` - if the test passes, the constraint is met (i.e., the field is valid)
 - `prohibits` - if the test passes, the constraint is not met (i.e., the field is invalid)
 
Putting it all together, constraint definitions should read like sentences:  
```scala
"Password must be at least 8 characters" validates that(password) prohibits { 
  _.password.length < 8 
}
```
```scala
"Password and Confirmation must match" validates that(confirmation) requires { form =>
  form.password == form.confirmation 
}
```
```scala
"Username already exists in the system" validates that(username) prohibits { form =>
  UserService.userExists(form.username) 
}
```

### Validations
A **Validation** is applied to an instance of a class with constraints.

Validations can be peformed in one of two ways:
 - **traditional** (Java-style runtime exception)
   ```scala
   try {
     UserService.updatePassword(user.validated.password)  // stores the user if it is a valid object
   } 
   catch {
     case e: ValidationException =>
       println(e.errors)  // prints the validation errors if user was invalid
   }
   ```
   - If validation succeeds, the original object is returned
   - If validation fails, an Exception is thrown
   
 - **functional** (Scala-style eithers)
   ```scala
   user.validate match {
     case Right(u) => 
       UserService.updatePassword(u.password)  // stores the user if it is a valid object
     case Left(e) => 
       println(e.errors)  // prints the validation errors if the user was invalid
   }
   ```
   - Returns either the original object (if validation succeeds), or an Exception object (if validation fails)

The traditional style may lead to cleaner code in frameworks where exceptions are handled at a global scale and the try-catch syntax can 
be omitted.  However, the functional style is generally preferred as it forces the developer 
to handle the error, and avoids the performance overhead associated with try-catch exception handling.


#### Validation Errors
Error messages generated by validation are grouped by field.
The following is an example of what `e.errors` may hold in the above examples:
```scala
Map(
  "email" -> List(
    "Email is required",
    "Email must be valid format"
  ),
  "password" -> List(
    "Password must be at least 8 characters"
  ),
  "confirmation" -> List(
    "Password and Confirmation must match"
  )
)
```